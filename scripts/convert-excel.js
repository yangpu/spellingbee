/**
 * Excel è¯åº“è½¬æ¢è„šæœ¬
 * ç”¨æ³•: node scripts/convert-excel.js <excelæ–‡ä»¶å> <åˆ†ç±»å>
 * ä¾‹å¦‚: node scripts/convert-excel.js grade3-400 grade3
 */
import XLSX from 'xlsx';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// è·å–å‘½ä»¤è¡Œå‚æ•°
const args = process.argv.slice(2);
const fileName = args[0] || 'grade3-400';
const category = args[1] || 'grade3';
const difficulty = parseInt(args[2]) || 2;

console.log(`\nğŸ“š è¯åº“è½¬æ¢å·¥å…·`);
console.log(`================`);
console.log(`æ–‡ä»¶: ${fileName}.xlsx`);
console.log(`åˆ†ç±»: ${category}`);
console.log(`é»˜è®¤éš¾åº¦: ${difficulty}\n`);

// è¯»å– Excel æ–‡ä»¶
const excelPath = path.join(__dirname, `../words/${fileName}.xlsx`);

if (!fs.existsSync(excelPath)) {
  console.error(`âŒ é”™è¯¯: æ‰¾ä¸åˆ°æ–‡ä»¶ ${excelPath}`);
  process.exit(1);
}

const workbook = XLSX.readFile(excelPath);

console.log('å·¥ä½œè¡¨åˆ—è¡¨:', workbook.SheetNames);

// è·å–ç¬¬ä¸€ä¸ªå·¥ä½œè¡¨
const sheetName = workbook.SheetNames[0];
const worksheet = workbook.Sheets[sheetName];

// è½¬æ¢ä¸º JSON
const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

console.log('æ€»è¡Œæ•°:', rawData.length);

// åˆ†ææ•°æ®ç»“æ„ - æ£€æŸ¥æ‰€æœ‰éç©ºçš„ç¬¬ä¸€åˆ—
let wordRows = [];
for (let i = 0; i < rawData.length; i++) {
  const row = rawData[i];
  if (row && row[0] && typeof row[0] === 'string' && row[0].trim() !== '' && row[0] !== 'Word') {
    wordRows.push({ index: i, word: row[0] });
  }
}
console.log('åŒ…å«å•è¯çš„è¡Œæ•°:', wordRows.length);

// è§£æå•è¯æ•°æ®
const words = [];

for (let i = 0; i < wordRows.length; i++) {
  const rowInfo = wordRows[i];
  const rowIndex = rowInfo.index;
  const row1 = rawData[rowIndex];
  const row2 = rawData[rowIndex + 1];
  
  const word = row1[0]?.toString().trim();
  const pronunciation = row1[1]?.toString().trim() || '';
  const definition = row1[2]?.toString().trim() || '';
  const partOfSpeech = row2?.[1]?.toString().trim() || '';
  const exampleSentence = row2?.[2]?.toString().trim() || '';
  
  if (word) {
    words.push({
      id: crypto.randomUUID(),
      word: word,
      pronunciation: pronunciation,
      definition: definition,
      part_of_speech: partOfSpeech,
      example_sentence: exampleSentence,
      difficulty: difficulty,
      category: category
    });
  }
}

console.log(`\nâœ… æˆåŠŸè§£æ ${words.length} ä¸ªå•è¯`);

// è¾“å‡ºç¤ºä¾‹
console.log('\nğŸ“ å‰5ä¸ªå•è¯ç¤ºä¾‹:');
words.slice(0, 5).forEach((w, i) => {
  console.log(`${i + 1}. ${w.word}`);
  console.log(`   å‘éŸ³: ${w.pronunciation}`);
  console.log(`   è¯æ€§: ${w.part_of_speech}`);
  console.log(`   é‡Šä¹‰: ${w.definition.substring(0, 60)}${w.definition.length > 60 ? '...' : ''}`);
  console.log('');
});

// ç”Ÿæˆ JSON æ–‡ä»¶
const outputPath = path.join(__dirname, `../public/words/${fileName}.json`);

// ç¡®ä¿ç›®å½•å­˜åœ¨
const outputDir = path.dirname(outputPath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// å†™å…¥ JSON æ–‡ä»¶
fs.writeFileSync(outputPath, JSON.stringify(words, null, 2), 'utf-8');
console.log(`\nğŸ’¾ JSON æ–‡ä»¶å·²ä¿å­˜åˆ°: ${outputPath}`);
console.log(`\nğŸ‰ è½¬æ¢å®Œæˆï¼`);
